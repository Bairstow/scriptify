'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Skeleton = exports.Cell = exports.Header = undefined;

var _ink = require('ink');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Components ----------------------------------------------------------------

const Header = (_ref) => {
  let children = _ref.children;
  return (0, _ink.h)(
    _ink.Bold,
    null,
    (0, _ink.h)(
      _ink.Color,
      { blue: true },
      children
    )
  );
};

Header.propTypes = {
  children: _propTypes2.default.any.isRequired
};

const Cell = (_ref2) => {
  let children = _ref2.children;
  return (0, _ink.h)(
    _ink.Color,
    null,
    children
  );
};

Cell.propTypes = {
  children: _propTypes2.default.any.isRequired
};

Cell.defaultProps = {
  focused: false
};

const Skeleton = (_ref3) => {
  let children = _ref3.children;
  return (0, _ink.h)(
    _ink.Bold,
    null,
    (0, _ink.h)(
      _ink.Color,
      { white: true },
      children
    )
  );
};

Skeleton.propTypes = {
  children: _propTypes2.default.any.isRequired

  // Helpers -------------------------------------------------------------------

};const get = key => obj => obj[key];
const length = el => el.length;
const isUndefined = v => v === undefined;
const not = func => function () {
  return !func(...arguments);
};
const toString = val => (val || String()).toString();
const isEmpty = el => el.length === 0;

const intersperse = val => vals => vals.reduce((s, c) => isEmpty(s) ? [c] : [...s, val(), c], []);
const fillWith = el => length => str => `${str}${el.repeat(length - str.length)}`;
const getCells = columns => data => columns.map((_ref4) => {
  let width = _ref4.width,
      key = _ref4.key;
  return { width: width, value: get(key)(data) };
});
const union = function union() {
  return [...new Set([].concat(...arguments))];
};

const generateColumn = padding => data => key => {
  const allColumns = data.map(get(key));
  const columnsWithValues = allColumns.filter(not(isUndefined));
  const vals = columnsWithValues.map(toString);
  const lengths = vals.map(length);

  const width = Math.max(...lengths, key.length) + padding * 2;

  return { width: width, key: key };
};

const copyToObject = func => arr => arr.reduce((o, k) => Object.assign({}, o, { [k]: func(k) }), {});
const generateHeadings = keys => copyToObject(key => key)(keys);
const generateSkeleton = keys => copyToObject(() => '')(keys);

const line = (Cell, Skeleton, _ref5) => {
  let line = _ref5.line,
      left = _ref5.left,
      right = _ref5.right,
      cross = _ref5.cross,
      padding = _ref5.padding;
  return cells => {
    const fillWithLine = fillWith(line);

    const columns = cells.map((_ref6) => {
      let width = _ref6.width,
          value = _ref6.value;
      return (0, _ink.h)(
        Cell,
        { key: value },
        line.repeat(padding),
        fillWithLine(width - padding)(toString(value))
      );
    });

    return (0, _ink.h)(
      'div',
      null,
      (0, _ink.h)(
        Skeleton,
        null,
        left
      ),
      intersperse(() => (0, _ink.h)(
        Skeleton,
        null,
        cross
      ))(columns),
      (0, _ink.h)(
        Skeleton,
        null,
        right
      )
    );
  };
};

// Table ---------------------------------------------------------------------

// Config --------------------------------------------------------------------

const Table = (_ref7) => {
  let data = _ref7.data,
      padding = _ref7.padding,
      header = _ref7.header,
      cell = _ref7.cell,
      skeleton = _ref7.skeleton;

  const topLine = line(skeleton, skeleton, { line: '─', left: '┌', right: '┐', cross: '┬', padding: padding });
  const bottomLine = line(skeleton, skeleton, { line: '─', left: '└', right: '┘', cross: '┴', padding: padding });
  const midLine = line(skeleton, skeleton, { line: '─', left: '├', right: '┤', cross: '┼', padding: padding });
  const headers = line(header, skeleton, { line: ' ', left: '│', right: '│', cross: '│', padding: padding });
  const row = line(cell, skeleton, { line: ' ', left: '│', right: '│', cross: '│', padding: padding });

  const keys = union(...data.map(Object.keys));
  const columns = keys.map(generateColumn(padding)(data));
  const headings = generateHeadings(keys);
  const _skeleton = generateSkeleton(keys);

  const getRow = getCells(columns);
  const headersRow = getRow(headings);
  const emptyRow = getRow(_skeleton);
  const rows = data.map(d => row(getRow(d)));

  return (0, _ink.h)(
    'span',
    null,
    topLine(emptyRow),
    headers(headersRow),
    midLine(emptyRow),
    intersperse(() => midLine(emptyRow))(rows),
    bottomLine(emptyRow)
  );
};

Table.propTypes = {
  data: _propTypes2.default.arrayOf(_propTypes2.default.object),
  padding: _propTypes2.default.number,
  header: _propTypes2.default.func,
  cell: _propTypes2.default.func,
  skeleton: _propTypes2.default.func
};

Table.defaultProps = {
  data: [],
  padding: 1,
  header: Header,
  cell: Cell,
  skeleton: Skeleton

  // Exports -------------------------------------------------------------------

};exports.default = Table;
exports.Header = Header;
exports.Cell = Cell;
exports.Skeleton = Skeleton;

// ---------------------------------------------------------------------------